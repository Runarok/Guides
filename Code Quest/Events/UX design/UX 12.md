# 1. Tokens — the atoms of C

Just like:

* **Letters → words**
* **Words → sentences**

In C:

* **Characters → tokens**
* **Tokens → statements**
* **Statements → programs**

A **token** is the **smallest meaningful unit** the compiler understands.

After **lexical analysis**, your entire program becomes **a stream of tokens**.
Whitespace and comments are gone. Meaning remains.

---

## The 6 categories of tokens in C

1. Keywords
2. Identifiers
3. Constants
4. Strings
5. Special symbols (punctuators)
6. Operators

Everything you write falls into one of these.

---

# 2. C Character Set (what tokens are made from)

The **C character set** includes:

* Letters: `A–Z`, `a–z`
* Digits: `0–9`
* Special characters:
  `{ } [ ] ( ) , ; : ? * & < > % = # _ " '`

These characters **don’t exist for decoration** — most of them:

* open / close code blocks
* terminate statements
* guide the compiler’s interpretation

Miss one, and the compiler gets lost.

---

# 3. Keywords (reserved words)

Keywords:

* Have **fixed meaning**
* Are **reserved**
* **Cannot** be used as identifiers
* Are **always lowercase** in C
* Total: **32**

Examples you’ll use constantly:

```c
int, if, else, for, while, return, void
```

### Why keywords matter

The parser treats:

```c
if (x > 0)
```

very differently from:

```c
x > 0
```

Because `if` is a **token with grammar rules**, not just text.

### Important warning

C is **case-sensitive**, so this technically works:

```c
int If = 5;
```

But this is **bad practice** and kills readability.
Never do it.

---

# 4. Identifiers (names you choose)

Identifiers are **user-defined names**:

* variables
* functions
* arrays
* structs
* enums

### Rules (non-negotiable)

✔ First character: **letter or underscore**
✔ Remaining: letters, digits, underscores
✘ No keywords
✘ No special characters
✘ No whitespace
✔ Case-sensitive

Valid:

```c
count
total_sum
_age
```

Invalid:

```c
2count     // starts with digit
total-sum  // hyphen not allowed
int        // keyword
total sum  // whitespace
```

### Practical advice

Don’t do this:

```c
int Age;
int age;
```

Yes, it compiles.
Yes, it’s legal.
No, it’s not intelligent.

Readable code beats clever code.

---

# 5. Variables vs Constants (memory reality)

### Variables

* Represent **real memory locations**
* Values can change during execution

```c
int score = 10;
score = 20;
```

### Constants

* Memory allocated once
* Value **never changes**

```c
const float PI = 3.14159;
```

Why constants matter:

* Safety
* Meaning
* Optimization
* Intent clarity

If something should never change — **say it explicitly**.

---

# 6. Punctuators (syntax markers)

Punctuators:

* Have **syntactic meaning**
* Do **not perform computation**
* Control structure and boundaries

Common ones:

```c
;  {}  ()  []  ,  :
```

### The semicolon (`;`)

The **most common bug source** in C.

It **terminates a statement**:

```c
int x = 5;
```

Miss it, and:

* compiler errors
* or worse — **logical bugs**

Your IDE screaming about a missing `;` is a blessing.

---

# 7. Operators (do the actual work)

Operators **tell the computer what to do**.

### Main categories

**Arithmetic**

```c
+  -  *  /  %
```

**Relational**

```c
==  !=  >  <  >=  <=
```

**Logical**

```c
&&  ||  !
```

**Assignment**

```c
=  +=  -=  *=  /=
```

**Bitwise**

```c
&  |  ^  ~  <<  >>
```

Each category has:

* different precedence
* different use cases
* different performance implications

(You’ll deep-dive later — this is just orientation.)

---

# 8. Functions — containers of behavior

A function:

* takes input
* performs computation
* optionally returns output

### General form

```c
return_type function_name(parameters)
{
    statements;
}
```

### Example: `main`

```c
int main(void)
{
    return 0;
}
```

Breakdown:

* `int` → return type
* `main` → function name
* `void` → no parameters
* `{}` → function body

Every program **starts here**.

---

# 9. Control structures (decision & repetition)

### `if`

```c
if (condition) {
    code;
} else {
    code;
}
```

### `switch`

Used when there are **many discrete options**:

```c
switch (choice) {
    case 1: break;
    case 2: break;
    default: break;
}
```

### `while`

```c
while (condition) {
    code;
}
```

### `for`

```c
for (init; condition; update) {
    code;
}
```

These structures exist because **linear execution is not enough**.

---

# 10. Data types (size matters)

Some core ones:

| Type                 | Purpose                   |
| -------------------- | ------------------------- |
| `char`               | smallest unit, characters |
| `int`                | general integers          |
| `float`              | decimal numbers           |
| `double`             | higher precision decimals |
| `unsigned long long` | largest standard integer  |

Important truth:

> Bigger types = more memory
> More memory ≠ better code

Use **what you need**, not what’s impressive.

---

# 11. Comments & whitespace (ignored, but essential)

### Comments

* **Not compiled**
* Removed before syntax analysis
* Exist only for humans

**Multi-line**

```c
/*
 * Explanation
 */
```

**Single-line**

```c
// explanation
```

⚠ Common mistake:
Forgetting to close `/*`
→ entire program becomes a comment

---

### Whitespace

Includes:

* spaces
* tabs
* newlines
* comments

Ignored by compiler **after tokenization**, but essential for:

* readability
* separating tokens

This must exist:

```c
int x;
```

This will not work:

```c
intx;
```

---

# 12. The real rule behind everything

C is:

* strict
* literal
* unforgiving

But predictable.

If you remember **one mantra**, make it this:

> **Every line must mean exactly one thing — clearly.**

Tokens are not theory.
They’re how the compiler **thinks**.

---
