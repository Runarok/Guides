# 1. What data types really are in C (the core idea)

In C, a data type is **not an abstract idea**.
It is a **contract with the hardware**.

> A data type answers three questions:

1. **How much memory?**
2. **How is that memory interpreted?**
3. **What operations are allowed?**

That’s why:

* Data types are **hardware-dependent**
* Sizes are defined as **minimums**
* C feels “close to the machine”

This is *intentional*, not a flaw.

---

# 2. The four classes of data types in C

C groups data types into **four families**:

1. **Basic (arithmetic) types**
2. **Enumerated types**
3. **Void**
4. **Derived types**

Everything else is built on top of these.

---

# 3. Basic data types (the arithmetic foundation)

These are split into **integer** and **floating-point** types.

---

## 3.1 Integer types (whole numbers)

### `char`

* **At least 8 bits**
* Stored as numbers (ASCII values)
* Can be:

  * `char`
  * `signed char`
  * `unsigned char`

Important truths:

* Characters are just numbers
* `'A'`, `'B'`, `'C'` are contiguous
* Arithmetic on `char` is legal

Example:

```c
char c = 'D';
c = c - 2;   // becomes 'B'
```

---

### `int`

* Stores **whole numbers**
* **No fractional part**
* Typical minimum range:

  * `-32768` to `32767`

Critical gotcha:

```c
int x = 22 / 7;   // result = 3
```

Fractional part is **discarded**, not rounded.

---

### Larger integers

| Type                | Purpose                        |
| ------------------- | ------------------------------ |
| `short`             | very small integers            |
| `long`              | larger range                   |
| `long long`         | massive range (often overkill) |
| `unsigned` variants | non-negative only              |

Rule of sanity:

> If overflow is *possible*, don’t use `int`.

But:

> Using the largest type everywhere is **lazy**, not safe.

---

## 3.2 Floating-point types (fractions)

Used when **precision matters**.

| Type          | Precision          |
| ------------- | ------------------ |
| `float`       | single precision   |
| `double`      | double precision   |
| `long double` | extended precision |

If you care about **fractions**, you must use these.

---

# 4. Boolean values in C (the “fake” truth)

C does **not** have a native boolean type in the traditional sense.

### Reality:

* `0` → false
* Non-zero → true

### Modern C (C99+):

```c
#include <stdbool.h>

bool flag = true;
```

Under the hood:

* `bool` is still an integer
* `_Bool` can only store `0` or `1`

Important:

> Anything non-zero becomes true
> That doesn’t mean you *should* rely on it

---

# 5. `void` — the absence of value

`void` means **“nothing”**, not “unknown”.

Used in three places:

---

## 5.1 Function returns

```c
void logMessage(void) {
    printf("Hello");
}
```

---

## 5.2 Function parameters

```c
int rand(void);
```

Means: *takes no arguments*.

---

## 5.3 Void pointers

```c
void *ptr;
```

A `void*`:

* Holds an address
* Has **no type information**
* Must be cast before use

This is how:

* memory allocators work
* generic data handling is possible

---

# 6. Fixed-width integer types (precision control)

When hardware variability becomes a problem, C gives you **exact sizes**.

```c
#include <stdint.h>

int8_t
int16_t
int32_t
int64_t
```

Use these when:

* binary formats matter
* networking
* embedded systems
* file structures

Rule:

> If size must be guaranteed → use fixed-width types

---

# 7. Choosing the *right* data type (this is the real skill)

Your choice should balance **five forces**:

1. **Requirements**
   What must this value represent?

2. **Future-proofing**
   Will this value grow over time?

3. **Convenience**
   Can humans reason about it?

4. **Performance**
   Does size matter *here*?

5. **Memory**
   Are resources constrained?

Golden rule:

> Premature optimization is worse than inefficiency.

---

# 8. Derived data types (power tools)

These build on basic types.

---

## 8.1 Arrays (contiguous memory)

An array is:

* Same type
* Fixed size
* Continuous memory

```c
char initials[15];
```

Important rules:

* Indexing starts at **0**
* Last index = `size - 1`
* Overflow = undefined behavior

Mental model:

> A row of identical boxes in memory

---

## 8.2 Pointers (addresses)

A pointer stores:

* **The address** of another variable

```c
int *ptr;
```

Think:

> Pointer = road sign
> Value = destination

Best practice:

```c
int *ptr = NULL;
```

Why `NULL` matters:

* Signals “points to nothing”
* Avoids random memory access
* Address `0` is protected by the OS

---

### Pointer superpowers (later lessons go deep):

* Pointer arithmetic
* Arrays of pointers
* Pointers to pointers
* Pass-by-reference
* Returning pointers

With power comes chaos if misused.

---

## 8.3 Unions (shared memory)

A union:

* Multiple members
* **One memory location**
* Only one active value at a time

```c
union Data {
    int i;
    char c;
};
```

Mental model:

> One chair, many possible sitters

Used when:

* memory is tight
* values are mutually exclusive

---

## 8.4 Structures (grouped data)

A struct:

* Groups **different types**
* Stored **contiguously**
* Each field has a fixed offset

```c
struct Point {
    int x;
    int y;
};
```

Used for:

* records
* models
* real-world entities

Unlike unions:

> All members exist at the same time

---

# 9. Type qualifiers (behavior modifiers)

Qualifiers **change how the compiler treats data**, not the data itself.

---

## `const`

```c
const int MAX = 100;
```

* Value cannot change
* Communicates intent
* Enables compiler optimization

---

## `volatile`

```c
volatile int clockTick;
```

Means:

* Value may change *outside* the program
* Compiler must not optimize reads

Common in:

* hardware registers
* OS callbacks
* embedded systems

---

## `restrict`

Used with pointers:

```c
int * restrict p;
```

Tells the compiler:

> This pointer is the **only access path** to that memory

Enables aggressive optimization.

⚠ Cannot be combined with `volatile`.

---

# 10. The real takeaway (this matters)

C does **not** protect you.

That’s the deal.

You get:

* control
* predictability
* performance

In exchange, you must:

* choose types deliberately
* understand memory
* respect hardware limits

> **Data types are decisions, not defaults.**

Once you grasp that, C stops being dangerous
and starts being precise.

---

