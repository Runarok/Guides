## 1. Arithmetic in C = Math + Direction

Arithmetic itself is familiar.
**The only mental shift** is this:

> In C, the **result always lives on the left**.

```c
total = 2 + 3;
difference = a - b;
```

This isn’t math notation.
It’s **assignment**: compute on the right → store on the left.

---

## 2. Increment & Decrement (where beginners slip)

### Basic forms

```c
a = a + 1;   // explicit
a++;        // post-increment
++a;        // pre-increment
```

### The real difference (important)

* **Pre-increment (`++a`)**: change value *before* use
* **Post-increment (`a++`)**: use value *before* change

Example:

```c
int a = 0;
printf("%d", ++a); // prints 1
printf("%d", a++); // prints 0, then a becomes 1
```

### Rule of thumb

* Use `i++` in loops
* Avoid mixing increment operators inside complex expressions
  (that’s where bugs breed)

---

## 3. Multiplication & Division (precision matters)

### Operators

```c
*   // multiplication
/   // division
```

### Critical rule

If **both operands are int**, result is **int**.

```c
int a = 5, b = 2;
float r = a / b;   // r = 2.0 ❌
```

Correct:

```c
float r = a / 2.0; // r = 2.5 ✅
```

> **Type of operands controls the result**, not the variable receiving it.

---

## 4. Logical Operators (decision-making tools)

| Operator | Meaning |   |    |
| -------- | ------- | - | -- |
| `&&`     | AND     |   |    |
| `        |         | ` | OR |
| `!`      | NOT     |   |    |

Example:

```c
if (time == 7 && moisture < 30) {
    water_plants();
}
```

Logical operators:

* Combine conditions
* Return **true (1)** or **false (0)**

Think **gates**, not arithmetic.

---

## 5. Assignment Operators (shorter + faster)

### Simple

```c
a = 10;
```

### Compound

```c
a += 10;   // a = a + 10
a -= 5;
a *= 2;
a /= 3;
a %= 2;
```

Why they matter:

* Less code
* Fewer CPU operations
* Clear intent

In tight loops, this *actually* matters.

---

## 6. Address (`&`) and Size (`sizeof`) — hardware awareness

### Address-of operator (`&`)

```c
scanf("%d", &a);
```

Meaning:

> “Store the input **at the memory location of `a`**”

Without `&`, `scanf` modifies a copy → value is lost.

---

### `sizeof`

```c
sizeof(int)
sizeof(a)
```

Returns **bytes**, not bits.

Why it matters:

* Hardware-dependent sizes
* Safe memory allocation
* Array size calculations

Example:

```c
int arr[10];
int count = sizeof(arr) / sizeof(arr[0]);
```

This is **foolproof**.

---

## 7. Expressions = operators + rules

Every computation is an **expression**.

Even this:

```c
a = b;
```

has:

* assignment operator
* evaluation order
* side effects

---

## 8. Operator Precedence (BODMAS still rules)

Order (simplified, practical):

1. Parentheses `()`
2. Increment / decrement
3. `* / %`
4. `+ -`
5. Relational `< <= > >=`
6. Equality `== !=`
7. Logical `&& ||`
8. Assignment `= += -=`
9. Comma `,`

Example:

```c
a + b * c   // multiplication first
```

If in doubt:

```c
a + (b * c)
```

> **Parentheses are clarity, not weakness.**

---

## 9. Associativity (when precedence ties)

* Most operators: **left → right**
* Assignment & ternary: **right → left**

Example:

```c
a = b = c = 5;
```

Evaluates as:

```c
a = (b = (c = 5));
```

---

## 10. Unary, Binary, Ternary (sanity check)

* **Unary**: one operand
  `++a`, `!flag`
* **Binary**: two operands
  `a + b`
* **Ternary**: three operands

  ```c
  max = (a > b) ? a : b;
  ```

If an operator doesn’t have the right number of operands → bug.

---

## 11. Bitwise Operators (why they exist)

They operate on **bits**, not values.

Why they’re used:

* Faster
* Lower power
* Critical in embedded systems

Examples:

```c
&  |  ^  ~  <<  >>
```

You don’t need them yet — just respect that they’re powerful and dangerous.

---

## 12. Quadratic equation demo — the real lesson

The error you’re asked to find:

```c
sqrt(b*b - 4*a*c)
```

Problem:

* Expression inside `sqrt` becomes **negative**
* Square root of negative → **domain error**

Fix (hint for next lesson):

* Check discriminant before `sqrt`
* Use conditionals

This is where **operators + logic + validation** meet.

---

## 13. The real takeaway (this is the core)

Operators are not symbols.
They are **contracts** between:

* data
* memory
* hardware
* intent

If you understand precedence, associativity, operand count, and data types, computers become predictable.

---
